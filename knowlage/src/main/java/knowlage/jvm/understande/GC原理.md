## GC原理

### OopMap: 使虚拟机快速的找到GC Roots  
OopMap中存储两种对象应用：  
1. 对象内的引用：在类加载完的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来了  
2. 栈、寄存器中的引用：在JIT编译过程中，也会在特定位置记录下栈和寄存器哪些位置是引用。  

### 安全点  
安全点就是特定的可以生成OopMap的指令，因为可以导致OopMap内容变化的指令非常多，我们不可能为每条指令都生成OopMap，所以引入了安全点
，只有在安全点的位置用户程序才能够暂停下来进行垃圾收集。  
什么样的地方可以设置成安全点呢？ 安全点选定的标准为：是否具有让程序长时间执行的特征。因为每条执行的执行时间都是短暂的，程序不太
可能因为指令流长度太长这样的原因而长时间执行，“长时间”执行的最明显特征就是指令序列的复用，例如方法跳转、循环跳转、异常跳转等，所
以只有具有这些功能的指令才会产生安全点。  

> 如何让线程都跑在安全点上？  两种方式：抢断式中断、主动式中断 
 
主动式中断：当GC需要中断线程时，不直接对线程操作，仅仅简单的设置一个标志位，各个线程在执行过程中或不停地主动去轮询这个标志，一旦
发现中断的标志为真时就自己在最近的安全点上主动挂起。  

### 记忆集
记忆集是一种用于记录从非收集区指向收集区域的指针集合的抽象数据结构。  

### 卡表
卡表是一种记忆集的实现方式。卡表所用的精度为“卡精度”（即每个记录精确到一块内存区域，该区域内有对象含有跨代指针）  

### 写屏障
> 用记忆集来缩减GC Root扫描范文的问题，那么我们是如何维护卡表元素的呢？  

首先我们要明确卡表元素核实变脏--有其他分代区域中的对象引用了本区域对象时，其对应的卡表元素就会变脏，变脏的时间点原则上应该发生
在应用类型字段赋值的那一刻  

在HotSpot虚拟机里是通过写屏障（Write Barrier）技术维护卡表状态的，写屏障可以看做在虚拟机层面对“引用类型字段赋值”这个动作的
AOP切面。

> 伪共享问题：现代中央处理器的缓存系统中是以缓存航（Cache Line）为单位存储的，当多线程修改相互独立的变量时，如果这些变量恰好共享
在同一个缓存航中，就会彼此影响（写回、无效化或者同步）而导致性能降低。

> 写屏障如何解决“伪共享”问题呢？  

一种简单的解决办法，就是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏。  
